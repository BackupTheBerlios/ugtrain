diff -urpN a/scanmem/handlers.c b/scanmem/handlers.c
--- a/scanmem/handlers.c	2012-07-12 07:00:52.000000000 +0200
+++ b/scanmem/handlers.c	2012-07-12 07:12:19.000000000 +0200
@@ -1335,6 +1335,115 @@ bool handler__dump(globals_t * vars, cha
     return true;
 }
 
+bool handler__dumparr(globals_t * vars, char **argv, unsigned argc)
+{
+    void *addr;
+    char *endptr;
+    char *buf = NULL;
+    char *prefix = NULL;
+    char empty_str = 0;
+    char file_name[256] = {0};
+    int len, min, max, idx;
+    FILE *dump_f = NULL;
+
+    if (argc < 5 || argc > 6)
+    {
+        show_error("bad argument, see `help dumparr`.\n");
+        return false;
+    }
+
+    /* check address */
+    errno = 0;
+    addr = (void *)(strtoll(argv[1], &endptr, 16));
+    if ((errno != 0) || (*endptr != '\0'))
+    {
+        show_error("bad address, see `help dumparr`.\n");
+        return false;
+    }
+
+    /* check element length */
+    errno = 0;
+    len = strtoll(argv[2], &endptr, 0);
+    if ((errno != 0) || (*endptr != '\0'))
+    {
+        show_error("bad length, see `help dumparr`.\n");
+        return false;
+    }
+
+    /* check min_idx */
+    errno = 0;
+    min = strtoll(argv[3], &endptr, 0);
+    if ((errno != 0) || (*endptr != '\0'))
+    {
+        show_error("bad min_idx, see `help dumparr`.\n");
+        return false;
+    }
+
+    /* check max_idx */
+    errno = 0;
+    max = strtoll(argv[4], &endptr, 0);
+    if ((errno != 0) || (*endptr != '\0'))
+    {
+        show_error("bad max_idx, see `help dumparr`.\n");
+        return false;
+    }
+
+    if ((max - min) >= 1000)
+    {
+        show_error("too many elements, see `help dumparr`.\n");
+        return false;
+    }
+
+    addr += (min * len);
+
+    /* check prefix */
+    if (argc == 6)
+    {
+        prefix = argv[5];
+    }
+    else
+    {
+        prefix = &empty_str;
+    }
+
+    buf = malloc(len + sizeof(long));
+    if (buf == NULL)
+    {
+        show_error("memory allocation failed.\n");
+        return false;
+    }
+
+    for (idx = 0; idx < max - min; idx++)
+    {
+        sprintf(file_name, "%s%03d", prefix, idx);
+        if ((dump_f = fopen(file_name, "wb")) == NULL)
+        {
+            show_error("failed to open file\n");
+            return false;
+        }
+
+        if (!read_array(vars->target, addr, buf, len))
+        {
+            show_error("read memory failed.\n");
+            free(buf);
+            return false;
+        }
+
+        size_t s = fwrite(buf, 1, len, dump_f);
+        fclose(dump_f);
+        if (s != len)
+        {
+            show_error("write to file failed.\n");
+            free(buf);
+            return false;
+        }
+        addr += len;
+    }
+
+    free(buf);
+    return true;
+}
+
 bool handler__write(globals_t * vars, char **argv, unsigned argc)
 {
     int data_width = 0;
diff -urpN a/scanmem/handlers.h b/scanmem/handlers.h
--- a/scanmem/handlers.h	2012-07-12 07:00:52.000000000 +0200
+++ b/scanmem/handlers.h	2012-07-12 07:06:31.000000000 +0200
@@ -235,6 +235,15 @@ bool handler__show(globals_t * vars, cha
     
 bool handler__dump(globals_t * vars, char **argv, unsigned argc);
 
+#define DUMPARR_SHRTDOC "dump an array of memory regions to files"
+#define DUMPARR_LONGDOC "usage: dumparr <address> <element_length> <min_idx> <max_idx> [<prefix>]\n" \
+                "\n" \
+                "If <prefix> is given, file names start with the prefix. \n" \
+                "Otherwise they start with their number direcly (e.g. \"005\").\n" \
+                "min_idx can also be negative if you want to look around a known address."
+
+bool handler__dumparr(globals_t * vars, char **argv, unsigned argc);
+
 #define WRITE_SHRTDOC "change the value of a specific memory location"
 #define WRITE_LONGDOC "usage: write <value_type> <address> <value>\n" \
                 "\n" \
diff -urpN a/scanmem/main.c b/scanmem/main.c
--- a/scanmem/main.c	2012-07-12 07:00:52.000000000 +0200
+++ b/scanmem/main.c	2012-07-12 07:02:21.000000000 +0200
@@ -190,6 +190,7 @@ int main(int argc, char **argv)
     registercommand("show", handler__show, vars->commands, SHOW_SHRTDOC, SHOW_LONGDOC);
     registercommand("dump", handler__dump, vars->commands, DUMP_SHRTDOC, DUMP_LONGDOC);
     registercommand("write", handler__write, vars->commands, WRITE_SHRTDOC, WRITE_LONGDOC);
+    registercommand("dumparr", handler__dumparr, vars->commands, DUMPARR_SHRTDOC, DUMPARR_LONGDOC);
     registercommand("option", handler__option, vars->commands, OPTION_SHRTDOC, OPTION_LONGDOC);
 
     /* commands beginning with __ have special meaning */
