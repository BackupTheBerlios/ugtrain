chromium-bsu

# Chromium B.S.U. 0.9.15 64-bit Linux
#
# $ ugtrain -P libmemhack64.so examples/chromium-bsu64
#
# This has the advantage that ugtrain and the game are in
# the same process group and ptrace may not require root.
#
# Alternative:
# 1. # ugtrain examples/chromium-bsu64
# 2. $ ugpreload libmemhack64.so chromium-bsu
#
# Here, we hook on dynamic memory (C++ constructor).

### Guided Automatic Adaption for your System ###
# $ ugtrain -A -P libmemdisc64.so examples/chromium-bsu64
#
# If automatic adaption fails, do full discovery!


dynmemstart HeroAircraft 288 0x411097 0x198

Lives 0xbc i32 l 9 1,9 a
check 0xbc i32 g 0
Damage 0xec f32 g -500.0 2,9 a
check 0xbc i32 g 0
Shield 0xf0 f32 l 1000.0 3,9 a
check 0xbc i32 g 0

Ammo_1 0xd0 f32 l 148.5 4,9 a
Ammo_2 0xd4 f32 l 148.5 5,9 a
Ammo_3 0xd8 f32 l 148.5 6,9 a
Ammo_1_en 0x58 u8 l 1 4,9 a
Ammo_2_en 0x59 u8 l 1 5,9 a
Ammo_3_en 0x5a u8 l 1 6,9 a

dynmemend

adapt_script adapt/chromium-bsu_adapt64.sh
adapt_required 1


# GameProcessName
#
#    The PID is searched by name with "pidof".
#
#    +++ Dynamic memory (e.g. C++ constructor) +++:
#
# dynmemstart ObjName ObjSize CodeJumpBackAddrOfMalloc OffsetOfCodeAddrOnStack
#
#    < Values + checks like in static memory but with ObjOffset as Addr >
#
#    Value:
# ValName OffsInObj DataType [optional check] WishValue KeyBindings ActState
#
#    Possible DataTypes: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64
#
#    checks: 'l' = "less than", 'g' = "greater than", '' = unchecked
#
#    KeyBindings are alphanumeric chars separated by ','. These are processed
#    by non-blocking getch and toggle the activation state at runtime. Multiple
#    keys for the same value and multiple values for the same key are possible.
#
#    The activation state can be directly set to active ('a') or deactivated
#    ('d') upon trainer start in the last colomn.
#
#    Check entry:
# check OffsInObj DataType <'l' or 'g'> CheckValue
#
#    Checks are applied to the previously defined value.
#
# dynmemend
#
#    Here, the object is closed. Static memory can follow.
#
# adapt_script RelScriptPath
#
#    A script can be run if requested by ugtrain (-A) to automatically adapt
#    the code address of a dynamic object in the config. Compilers and their
#    options differ from distribution to distribution. Also the game version
#    may differ. But if the object size is still the same, then there is a
#    good chance to adapt by searching for the allocation in the disassembly.
#    The path is relative to the config path.
#
# adapt_required 1
#
#    This is meant to ensure that the user is asked if he wants the automatic
#    adaption to be run when he uses this config the first time. This is why
#    this option is likely set in examples. It can be set to '0' afterwards.
#
#####
#
#    Dynamic memory always needs the preloader. Here, only the code address
#    in the binary where "malloc" is called remains static.
#    See linuxhooking/examples how to discover and adapt it to other versions.
#
#    Call the trainer first. Then, call the preloaded game in another terminal.
#    Use the preloader for hooking libmemhack64.so into the game process. The
#    trainer might require root permissions due to ptrace for a process in
#    another process group.
#    So it's better to let the trainer run the preloader with:
#    "ugtrain -P [lib] <config>".
