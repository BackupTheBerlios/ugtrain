chromium-bsu

# Chromium B.S.U. 0.9.15 32-bit Linux
#
# $ ugtrain -P libmemhack32.so examples/chromium-bsu32
#
# This has the advantage that ugtrain and the game are in
# the same process group and ptrace may not require root.
#
# Alternative:
# 1. # ugtrain examples/chromium-bsu32
# 2. $ ugpreload libmemhack32.so chromium-bsu
#
# Here, we hook on dynamic memory (C++ constructor).


dynmemstart HeroAircraft 272 0x8057219 0x174

Lives 0xb0 u8 l 9 1,9 a
check 0xb0 u8 g 0
Damage 0xe0 f32 g -500.0 2,9 a
Shield 0xe4 f32 l 1000.0 3,9 a

Ammo_1 0xc4 f32 l 148.5 4,9 a
Ammo_2 0xc8 f32 l 148.5 5,9 a
Ammo_3 0xcc f32 l 148.5 6,9 a
Ammo_1_en 0x4c u8 l 1 4,9 a
Ammo_2_en 0x4d u8 l 1 5,9 a
Ammo_3_en 0x4e u8 l 1 6,9 a

dynmemend

adapt_script adapt/chromium-bsu_adapt32.sh
adapt_required 1


# GameProcessName
#
#    The PID is searched by name with "pidof".
#
#    +++ Dynamic memory (e.g. C++ constructor) +++:
#
# dynmemstart ObjName ObjSize CodeJumpBackAddrOfMalloc OffsetOfCodeAddrOnStack
#
#    < Values + checks like in static memory but with ObjOffset as Addr >
#
#    Value:
# ValName OffsInObj DataType [optional check] WishValue KeyBindings ActState
#
#    Possible DataTypes: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64
#
#    checks: 'l' = "less than", 'g' = "greater than", '' = unchecked
#
#    KeyBindings are alphanumeric chars separated by ','. These are processed
#    by non-blocking getch and toggle the activation state at runtime. Multiple
#    keys for the same value and multiple values for the same key are possible.
#
#    The activation state can be directly set to active ('a') or deactivated
#    ('d') upon trainer start in the last colomn.
#
#    Check entry:
# check OffsInObj DataType <'l' or 'g'> CheckValue
#
#    Checks are applied to the previously defined value.
#
# dynmemend
#
#    Here, the object is closed. Static memory can follow.
#
# adapt_script RelScriptPath
#
#    A script can be run if requested by ugtrain to automatically adapt
#    the code address of a dynamic object in the config. Compilers and their
#    options differ from distribution to distribution. Also the game version
#    may differ. But if the object size is still the same, then there is a
#    good chance to adapt by searching for the allocation in the disassembly.
#    The path is relative to the config path.
#
#    Dynamic memory always needs the preloader. Here, only the code address
#    in the binary where "malloc" is called remains static.
#    See linuxhooking/examples how to discover and adapt it to other versions.
#
#    Call the trainer first. Then, call the game with the preloader hooking
#    libmemhack32.so into the game process.
