=== Dynamic Memory Cheating ===

Cheating dynamic memory always requires a preloader which loads a memory
hacking library into the game process. The ugtrain uses "ugpreload" and
"libmemhack" for that. The library gets the unique code addresses of unique
"malloc()" calls and their reverse stack offsets as a config through a FIFO.
The lib reports back through another FIFO which objects have been allocated
to which memory addresses. It also keeps track of these memory addresses and
sends the information about the freeing of these memory objects through the
output FIFO. This is required for stability.
You can call this "dynamic memory spying" if you will.

== Details ==

The preloader ugpreload only appends libmemhack to the environment variable
"LD_PRELOAD" and runs the game. The dynamic loader "ld.so" does the rest. You
can choose another preloader if you want like "glc-capture" for recording a
game cheating video. But please ensure that libmemhack is loaded first into
the game process. See the "--pre-cmd" and "--glc" ugtrain options.

The lib has a constructor function, a malloc() and a free() hook. It wraps
these functions. In the constructor the lib opens the input and the output
FIFO and tries for 1 second to read the config. If there is no config or there
is an error in the config, then it doesn't get active. This means that it
operates like libc malloc() and free(). But activated, it compares for each
malloc first the malloc size and then the code address at the reverse stack
offset with the config. If it matches, it sends the code and the memory address
(returned by libc malloc) through the FIFO. The memory address is put into the
in-memory config to be used for the free() hook. There we only compare memory
addresses in order to find a free() which is relevant to be reported for now.
One could think about backtracing there as well for optimization but how to
discover/adapt that and ensure that we've found all free() calls for that
class?!

The in-memory config is at a static memory location and uses a fixed size of
e.g. four memory pages (4 * 4096 bytes). In this memory area libmemhack stores
all important data like config pointers, config entries and the memory
addresses of the currently allocated objects. These are filled with an invalid
pointer value in the constructor and the last value is always that invalid
pointer. This way free() only iterates until it hits an invalid pointer. The
found memory address is set to NULL and malloc() can re-use it. This way the
first invalid pointer represents the number of objects which had to be kept
track of at once. The more objects there are, the slower it gets. All this is
quite hacky but it's the most flexible way with performance in mind.

Note: The constructor tells the user of how many memory objects per memory
class libmemhack can keep track of. The more classes you cheat, the less it
gets. And don't worry: libmemhack gets an own independent memory area for its
config data. So static memory cheating works no matter if libmemhack is
preloaded or not.

== ugtrain Specialties ==

The CLI option '-P' is recommended for dynamic memory cheating. With that
libmemhack is preloaded and the game is started automatically. The advantage
is that root permissions (for ptrace) aren't required - same process group!

Required config options: "dynmemstart", "dynmemend"
Related config options: "checko"
FIFOs: /tmp/memhack_in, /tmp/memhack_out

Value locations are used as offsets within the objects. They become only active
if at least one object has been allocated. The lib sends the code and the
memory address through the FIFO to ugtrain. The ugtrain appends this to a
vector of memory addresses in the right memory class then. It also grows the
old value vectors per configured value in that class. This way ugtrain always
knows which value was in memory before changing it and can show it to the user.
Displaying all values at once would be too much. This is why ugtrain uses a
print index. With the keys '+' and '-' the print index for all memory classes
is increased or decreased. In case you need a snapshot/dump of all objects, use
the '>' key.

We can use a special check ("checko") if the allocated object belongs to us or
otherwise an opponent. If it fails, it removes the object from the active
ugtrain in-memory config by setting its memory address to NULL. Following
values in that object are not processed anymore. After leaving the critical
section, the object is cleaned up in the vectors and the user is informed. This
behaves very similar like having received a free() from libmemhack.

But keep in mind: libmemhack doesn't know about that. It still tracks kicked-
out objects and will send a free() for these.

The rest works the same way as with static memory.


=== Dynamic Memory Discovery ===

For discovery another library is required ("libmemdisc"). This one takes a
stage number and the stage parameters as config and is preloaded with ugpreload
as well.

Discovery is done in the following stages:

1. Find the malloc size           (all mallocs and frees are recorded)
2. Verify the malloc size         (frees are ignored)
3. Find the code address
4. Find the reverse stack offset

The ugtrain option '-D' helps with that. It assumes '-P' and libmemdisc. All
we need are the following stage parameters for the '-D' option:

1. "StageNr[;HeapStartOffs;HeapEndOffs]"
2. "StageNr[;HeapStartOffs;HeapEndOffs;MemSize]"
3. "StageNr;HeapStartOffs;HeapEndOffs;MemSize[;CodeStart;CodeEnd]"
4. "StageNr;HeapStartOffs;HeapEndOffs;MemSize[;CodeStart;CodeEnd][;CodeAddr]"

Examples:

1. "1", "1;0x0;0x0", "1;0x200000;0x350000"
2. "2", "2;0x0;0x0;0", "2;0x200000;0x350000;288"
3. "3;0x0;0x0;288", "3;0x200000;0x350000;288;0x404d50;0x425c88"
4. "4;0x0;0x0;288", "4;0x200000;0x350000;288;0x404d50;0x425c88;0x40f4e7"

You see, we can also do this in only two stages: stages 2 and 4. Size 0 means
that all sizes are recorded in stage 2. The ugtrain expands the first example
string to the second in stages 1 and 2. 0x0;0x0 in the heap filter means
unfiltered. The libmemdisc tells you about heap start and stack end. In stages
3 and 4 ugtrain finds out the code start and end for you by "objdump -p"-based
binary header extraction. Only the malloc size is important there.

Returns:

1. "m0x87acd0;s288", "f0x87acd0"
--> 'm' for malloc and 'f' for free, the address is the memory address of
the object, 's' is the size in bytes
2. "m0x87acd0;s288"
3. "m0x87acd0;s288;c0x40f4e7;c0x417801"
--> 'c' is the code address in the backtrace
4. "m0x87acd0;s288;c0x40f4e7;o0x28;c0x417801;o0x48"
--> 'o' is the reverse stack offset of the code address

The results are written with caching directly from /tmp/memhack_out into the
file /tmp/memhack_file. After ending the game ugtrain asks you for a memory
address from parallel static memory search. Enter it and ugtrain will search
for the matching malloc calls. It is very likely that interesting objects
are kept until game end. So they should be at the end of that list. But as in
stages 3 and 4 the "objdump -D"-based symbol lookup is quite slow, we reverse
that list and the interesting malloc is at the top. This way you can interrupt
the symbol lookup earlier.

Example stage 2:

$ ugtrain -D "2" examples/chromium-bsu64.conf
...
Memory address (e.g. 0xdeadbeef): 0x87ad8c
Searching reverse for 0x87ad8c in discovery output..
m0x87acd0;s288 contains 0x87ad8c, offs: 0xbc, heap offs: 0x2257f0
m0x87acd0;s344 contains 0x87ad8c, offs: 0xbc, heap offs: 0x2257f0
m0x87acd0;s344 contains 0x87ad8c, offs: 0xbc, heap offs: 0x2257f0
...

This shows us that the malloc size is 288 bytes and the offset in the object
is 0xbc (used the lives in the HeroAircraft object in Chromium B.S.U. 64-bit).
We also get to know the heap offset.

Example stage 4:

$ ugtrain -D "4;0x0;0x0;288" examples/chromium-bsu64.conf
...
Memory address (e.g. 0xdeadbeef): 0x8a605c
Searching reverse for 0x8a605c in discovery output..
m0x8a5fa0;s288 contains 0x8a605c, offs: 0xbc, heap offs: 0x250ac0
c0x40f4e7;o0x28 <_Znwm@plt>
c0x417801;o0x48
c0x404be6;o0x78
...

Only <*@plt> direct library calls are displayed and "_Znwm" on the first
position is exactly what we are looking for. It is a C++ internal function
which calls "malloc" internally. On 32-bit systems it is called "_Znwj".
We can see the reverse stack offset is 0x28. It would be lower if "malloc"
would have been called directly from the game binary (e.g. 0x8). We also
get to know the code jump back address 0x40f4e7.

That's it! We can write a basic config for the lives in chromium-bsu. We
start with a watcher in order to verify that our findings are correct.

chromium-bsu
dynmemstart HeroAircraft 288 0x40f4e7 0x28
Lives 0xbc i32 watch
dynmemend

$ ugtrain -P test.conf


=== Finding more Values in Dynamic Memory ===

In the game we can use the object dump now by pressing the '>' key. For our
example there should be the HeroAircraft object dumped as "0_000.dump". Before
the '_' there is the class index and after it the object index. Just compare
two dumps: when you are low on everything and when you are high on everything.
This way you can easily find other values like ammo and shields. A zero is also
with a float a zero in hex. The .dump files are binary files so either you use
a binary diff tool or you convert it into text first and use a text diff tool
like e.g. "meld". Conversion can be done as follows:

$ xxd 0_000.dump > 0_000.dump.txt

The tool "xxd" is part of the "vim" package.

If you've got a lot of objects and don't know exactly which ones are yours and
which ones are enemies, use the binary diff tool "ugsimfind". It compares upto
100 object files byte by byte and tells you for each byte its value as well as
how many and which files have the same value. This is very very useful if you
are searching the u8 player ID in Warzone 2100 Droids. Use it as follows:

$ ugsimfind 0_*.dump | less

fidx: 0x22
0x00 '.' : 7    0_000.dump, 0_001.dump, 0_042.dump, 0_043.dump, 0_044.dump,
0_045.dump, 0_046.dump,
0x07 '.' : 26   0_002.dump, 0_003.dump, 0_004.dump, 0_005.dump, 0_006.dump,
0_007.dump, 0_008.dump, ...,
0x06 '.' : 14   0_010.dump, 0_011.dump, 0_012.dump, 0_019.dump, 0_020.dump,
0_021.dump, 0_022.dump, ...,

The campaign starts with 7 own Droids and 40 enemies in Warzone 2100. From the
name string we know that these are exactly these 7. We have player ID 0 and the
AI has ID 6 and ID 7. So at offset 0x22 is our player ID.


=== Dynamic Memory Adaption ===
